use crate::ast::*;
use crate::Symbol;

grammar;

extern {
    type Error = String;
}

// lexer
match {
    r"\s*" => { }, // skip whitespace
    r";[^\n\r]*[\n\r]*" => { }, // skip ; comments
    r"Int|int|I64|number" => reserved,
    _
}

pub Program: Vec<Command> = { (Command)* => <> }

List<T>: Vec<T> = { 
    "(" <T*> ")" => <>,
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Command: Command = {
    "(" "datatype" <name:Name> <variants:(Variant)*> ")" => Command::Datatype { <> },
    "(" "sort" <name:Name> "(" <head:Name> <tail:(Expr)*> ")" ")" => Command::Sort (<>),
    "(" "function" <name:Name> <schema:Schema> <cost:Cost>
        <merge:(":merge" <Expr>)?> <default:(":default" <Expr>)?> ")" => {
        Command::Function(FunctionDecl { name, schema, merge, default, cost })
    },
    "(" "relation" <name:Name> <types:List<Type>> ")" => Command::Function(FunctionDecl::relation(name, types)),
    "(" "rule" <body:List<Fact>> <head:List<Action>> ")" => Command::Rule(Rule { head, body }),
    "(" "rewrite" <lhs:Expr> <rhs:Expr>
        <conditions:(":when" <List<Fact>>)?>
    ")" => Command::Rewrite(Rewrite { lhs, rhs, conditions: conditions.unwrap_or_default() }),
    "(" "birewrite" <lhs:Expr> <rhs:Expr>
        <conditions:(":when" <List<Fact>>)?>
    ")" => Command::BiRewrite(Rewrite { lhs, rhs, conditions: conditions.unwrap_or_default() }),
    "(" "define" <name:Name> <expr:Expr> <cost:Cost> ")" => Command::Define { name, expr, cost },
    <NonLetAction> => Command::Action(<>),
    "(" "run" <limit:UNum>  <until:(":until" <Fact>)?> ")" => Command::Run(RunConfig { limit, until }),
    "(" "calc" "(" <idents:IdentSort*> ")" <exprs:Expr+> ")" => Command::Calc(idents, exprs),
    "(" "extract" <variants:(":variants" <UNum>)?> <e:Expr> ")" => Command::Extract { e, variants: variants.unwrap_or(0) },
    "(" "check" <Fact> ")" => Command::Check(<>),
    "(" "clear-rules" ")" => Command::ClearRules,
    "(" "clear" ")" => Command::Clear,
    "(" "query" <List<Fact>> ")" => Command::Query(<>),
    "(" "push" <UNum?> ")" => Command::Push(<>.unwrap_or(1)),
    "(" "pop" <UNum?> ")" => Command::Pop(<>.unwrap_or(1)),
    "(" "print" <sym:Ident> <n:UNum?> ")" => Command::Print(sym, n.unwrap_or(10)),
    "(" "print-size" <sym:Ident> ")" => Command::PrintSize(sym),
    "(" "input" <name:Name> <file:String> ")" => Command::Input { name, file },
}

Cost: Option<usize> = {
    ":cost" <UNum> => Some(<>),
    => None,
}

NonLetAction: Action = {
    "(" "set" "(" <f: Ident> <args:Expr*> ")" <v:Expr> ")" => Action::Set ( f, args, v ),
    "(" "delete" "(" <f: Ident> <args:Expr*> ")" ")" => Action::Delete ( f, args),
    "(" "union" <e1:Expr> <e2:Expr> ")" => Action::Union(<>),
    "(" "panic" <msg:String> ")" => Action::Panic(msg),
    <e:CallExpr> => Action::Expr(e),
}

Action: Action = {
    "(" "let" <name:Name> <expr:Expr> ")" => Action::Let(name, expr),
    <NonLetAction> => <>,
}

Fact: Fact = {
    "(" "=" <mut es:Expr+> <e:Expr> ")" => {
        es.push(e);
        Fact::Eq(es)
    },
    <Expr> => Fact::Fact(<>),
}

Schema: Schema = {
    <types:List<Type>> <output:Type> => Schema { input: types, output }
}

Expr: Expr = {
    <Literal> => Expr::Lit(<>),
    <Name> => Expr::Var(<>),
    <CallExpr> => <>,
};

Literal: Literal = {
    // "(" ")" => Literal::Unit, // shouldn't need unit literals for now
    <Num> => Literal::Int(<>),
    <SymString> => Literal::String(<>),
}

CallExpr: Expr = {
    "(" <head:Ident> <tail:(Expr)*> ")" => Expr::Call(head, tail),
}

ExprList: Vec<Expr> = { "(" <sexps:(Expr)*> ")" => sexps }

Variant: Variant = {
    "(" <name:Name> <types:(Type)*> <cost:Cost> ")" => Variant { <> },
}

Type: Symbol = <Ident>;

IdentSort: IdentSort = "(" <ident:Name> <sort:Type> ")" => IdentSort { ident, sort };
Num: i64 = <s:r"(-)?[0-9]+"> => s.parse().unwrap();
UNum: usize = {
    <Num> => <>.try_into().unwrap(),
}
Bool: bool = {
    "true" => true,
    "false" => false,
}
Scope : Symbol = <Name> "::" => <>;
Ident : Ident = <scope:Scope*> <name:Name> => Ident{name, scope};
Name: Symbol = <s:r"([[:alpha:]][\w-]*)|([-+*/!=<>&|^/%]+)"> => s.parse().unwrap();
SymString: Symbol = <r#""[^"]*""#> => Symbol::from(<>);
String: String = <r#""[^"]*""#> => (<>).trim_matches('"').to_owned();
