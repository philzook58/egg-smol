;ThCompleteCategory
(datatype TYPE)
(datatype TERM)
(function type (TERM) TYPE)
(function Ob () TYPE)
(function Hom (TERM TERM) TYPE)
(function Terminal () TYPE)
(function Product (TERM TERM) TYPE)
(function Equalizer (TERM TERM) TYPE)

(function id (TERM) TERM)
(rule ((= goofball (id A)))  ((let goofball_demand (type goofball)) (let A_type (type A))))
(rewrite (type (id A)) (Hom A A) :when ((= (type A) Ob)))

(function compose (TERM TERM) TERM)
(rule ((= goofball (compose f g)))  ((let goofball_demand (type goofball)) (let f_type (type f)) (let g_type (type g))))
(rewrite (type (compose f g)) (Hom A C) :when ((= (type f) (Hom A B)) (= (type g) (Hom B C))))

(function terminal () TERM)
(rule ((= goofball (terminal )))  ((let goofball_demand (type goofball)) ))
(rewrite (type (terminal )) (Terminal ) :when ())

(function ob (TERM) TERM)
(rule ((= goofball (ob ⊤)))  ((let goofball_demand (type goofball)) (let ⊤_type (type ⊤))))
(rewrite (type (ob ⊤)) Ob :when ((= (type ⊤) (Terminal ))))

(function delete (TERM TERM) TERM)
(rule ((= goofball (delete ⊤ C)))  ((let goofball_demand (type goofball)) (let ⊤_type (type ⊤)) (let C_type (type C))))
(rewrite (type (delete ⊤ C)) (Hom C (ob ⊤)) :when ((= (type ⊤) (Terminal )) (= (type C) Ob)))

(function product (TERM TERM) TERM)
(rule ((= goofball (product A B)))  ((let goofball_demand (type goofball)) (let A_type (type A)) (let B_type (type B))))
(rewrite (type (product A B)) (Product A B) :when ((= (type A) Ob) (= (type B) Ob)))

(function ob (TERM) TERM)
(rule ((= goofball (ob Π)))  ((let goofball_demand (type goofball)) (let Π_type (type Π))))
(rewrite (type (ob Π)) Ob :when ((= (type Π) (Product A B))))

(function proj1 (TERM) TERM)
(rule ((= goofball (proj1 Π)))  ((let goofball_demand (type goofball)) (let Π_type (type Π))))
(rewrite (type (proj1 Π)) (Hom (ob Π) A) :when ((= (type Π) (Product A B))))

(function proj2 (TERM) TERM)
(rule ((= goofball (proj2 Π)))  ((let goofball_demand (type goofball)) (let Π_type (type Π))))
(rewrite (type (proj2 Π)) (Hom (ob Π) B) :when ((= (type Π) (Product A B))))

(function pair (TERM TERM TERM) TERM)
(rule ((= goofball (pair Π f g)))  ((let goofball_demand (type goofball)) (let Π_type (type Π)) (let f_type (type f)) (let g_type (type g))))
(rewrite (type (pair Π f g)) (Hom C (ob Π)) :when ((= (type Π) (Product A B)) (= (type f) (Hom C A)) (= (type g) (Hom C B))))

(function equalizer (TERM TERM) TERM)
(rule ((= goofball (equalizer f g)))  ((let goofball_demand (type goofball)) (let f_type (type f)) (let g_type (type g))))
(rewrite (type (equalizer f g)) (Equalizer f g) :when ((= (type f) (Hom A B)) (= (type g) (Hom A B))))

(function ob (TERM) TERM)
(rule ((= goofball (ob eq)))  ((let goofball_demand (type goofball)) (let eq_type (type eq))))
(rewrite (type (ob eq)) Ob :when ((= (type eq) (Equalizer f g))))

(function incl (TERM) TERM)
(rule ((= goofball (incl eq)))  ((let goofball_demand (type goofball)) (let eq_type (type eq))))
(rewrite (type (incl eq)) (Hom (ob eq) A) :when ((= (type eq) (Equalizer f g))))

(function factorize (TERM TERM TERM) TERM)
(rule ((= goofball (factorize eq h eq_h)))  ((let goofball_demand (type goofball)) (let eq_type (type eq)) (let h_type (type h)) (let eq_h_type (type eq_h))))
(rewrite (type (factorize eq h eq_h)) (Hom (ob eq_h) (ob eq)) :when ((= (type eq) (Equalizer f g)) (= (type h) (Hom C A)) (= (type eq_h) (Equalizer (⋅ h f) (⋅ h g)))))


(birewrite (compose (compose f g) h) (compose f (compose g h)) :when ((= (type A) Ob) (= (type B) Ob) (= (type C) Ob) (= (type D) Ob) (= (type f) (Hom A B)) (= (type g) (Hom B C)) (= (type h) (Hom C D))))
(birewrite (compose f (id B)) f :when ((= (type A) Ob) (= (type B) Ob) (= (type f) (Hom A B))))
(birewrite (compose (id A) f) f :when ((= (type A) Ob) (= (type B) Ob) (= (type f) (Hom A B))))
(birewrite (compose (pair Π f g) (proj1 Π)) f :when ((= (type A) Ob) (= (type B) Ob) (= (type C) Ob) (= (type Π) (Product A B)) (= (type f) (Hom C A)) (= (type g) (Hom C B))))
(birewrite (compose (pair Π f g) (proj2 Π)) g :when ((= (type A) Ob) (= (type B) Ob) (= (type C) Ob) (= (type Π) (Product A B)) (= (type f) (Hom C A)) (= (type g) (Hom C B))))
(birewrite f g :when ((= (type C) Ob) (= (type ⊤) (Terminal )) (= (type f) (Hom C (ob ⊤))) (= (type g) (Hom C (ob ⊤)))))
(birewrite (pair (compose h (proj1 Π)) (compose h (proj2 Π))) h :when ((= (type A) Ob) (= (type B) Ob) (= (type C) Ob) (= (type Π) (Product A B)) (= (type h) (Hom C (ob Π)))))
(birewrite (compose (incl eq) f) (compose (incl eq) g) :when ((= (type A) Ob) (= (type B) Ob) (= (type f) (Hom A B)) (= (type g) (Hom A B)) (= (type eq) (Equalizer f g))))
(birewrite (incl eq) (id A) :when ((= (type A) Ob) (= (type B) Ob) (= (type f) (Hom A B)) (= (type eq) (Equalizer f f))))
(birewrite (compose (factorize eq h eq_h) (incl eq)) (compose (incl eq_h) h) :when ((= (type A) Ob) (= (type B) Ob) (= (type C) Ob) (= (type f) (Hom A B)) (= (type g) (Hom A B)) (= (type h) (Hom C A)) (= (type eq) (Equalizer f g)) (= (type eq_h) (Equalizer (⋅ h f) (⋅ h g)))))
(birewrite (factorize eq (compose k (incl eq)) eq_k) k :when ((= (type A) Ob) (= (type B) Ob) (= (type D) Ob) (= (type f) (Hom A B)) (= (type g) (Hom A B)) (= (type eq) (Equalizer f g)) (= (type k) (Hom D (ob eq))) (= (type eq_k) (Equalizer (⋅ (⋅ k (incl eq)) f) (⋅ (⋅ k (incl eq)) g)))))
